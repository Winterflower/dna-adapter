"""
The module preprocess contains pure functions for preprocessing sequence data in
fasta format.
This module contains functions adapted from 'kmersvm' by Dongwon Lee (2011).
There are marked in the docstring.
The identation in this module is 'tab' to be consistent with legacy code.
"""
from __future__ import division
import numpy
from ordereddict import OrderedDict
import sys
import random
import math
import copy

def generate_kmers(kmerlen):
        """
	Returns a list of all possible kmers of length kmerlen

	:author Dongwon Lee (2011)

        Arguments:
        kmerlen -- integer, length of k-mer

        Return:
        a list of the full set of k-mers

	>>> preprocess.generate_kmers(2)
	['AA', 'AC', 'AG', 'AT', 'CA', 'CC', 'CG', 'CT', 'GA', 'GC', 'GG', 'GT', 'TA', 'TC', 'TG', 'TT']

        """

        nts = ['A', 'C', 'G', 'T']
        kmers = []
        kmers.append('')
        l = 0
        while l < kmerlen:
                imers = []
                for imer in kmers:
                        for nt in nts:
                                imers.append(imer+nt)
                kmers = imers
                l += 1

        return kmers

def revcomp(seq):
	"""
	Returns the reverse complement of a DNA sequence
	
	:author Dongwon Lee (2011)

	Arguments:
	seq -- string, DNA sequence

	Return:
	the reverse complement sequence of the given sequence

	>>> preprocess.revcomp('ACCCGGGTTATTTATTTT')
	'AAAATAAATAACCCGGGT'

	"""
	rc = {'A':'T', 'G':'C', 'C':'G', 'T':'A'}
	return ''.join([rc[seq[i]] for i in xrange(len(seq)-1, -1, -1)])


def generate_rcmap_table(kmerlen, kmers, print_dict=False):
	"""
	Returns a mapping list which maps a k-mer to its reverse complement. 
	
	:author Dongwon Lee (2011)
	Method has been modified by Camilla Montonen (2014)

	Arguments:
	kmerlen -- integer, length of k-mer
	kmers -- list, a full set of k-mers generated by generate_kmers
	print_dict, a boolean to indicate whether the kmer mapping dictionary should be printed

	Return:
	a dictionary containing the mapping table

	>>> preprocess.generate_rcmap_table(2,preprocess.generate_kmers(2))
	[0, 1, 2, 3, 4, 5, 6, 2, 8, 9, 5, 1, 12, 8, 4, 0]

	>>> preprocess.generate_rcmap_table(2,preprocess.generate_kmers(2),True)
	{'AA': 0, 'AC': 1, 'GT': 11, 'AG': 2, 'CC': 5, 'CA': 4, 'CG': 6, 'TT': 15, 'GG': 10, 'GC': 9, 'AT': 3, 'GA': 8, 'TG': 14, 'TA': 12, 'TC': 13, 'CT': 		7}
	[0, 1, 2, 3, 4, 5, 6, 2, 8, 9, 5, 1, 12, 8, 4, 0]

	"""
	revcomp_func = revcomp

	kmer_id_dict = {}
	for i in xrange(len(kmers)): 
		kmer_id_dict[kmers[i]] = i

	revcomp_mapping_table = []
	for kmerid in xrange(len(kmers)): 
		rc_id = kmer_id_dict[revcomp_func(kmers[kmerid])]
		if rc_id < kmerid:
			revcomp_mapping_table.append(rc_id)
		else:
			revcomp_mapping_table.append(kmerid)
	if print_dict:
		print kmer_id_dict
	return revcomp_mapping_table



def read_fastafile(filename, subs=True):
	"""
	Returns a list of sequences and a list of sequence FASTA headers from a file in FASTA format
	
	:author Dongwon Lee (2011)
	Modified by Camilla Montonen (2014)

	Arguments:
	filename -- string, the name of the sequence file in FASTA format
	subs -- bool, substitute 'N' with 'A' if set true

	Return: 
	list of sequences, list of sequence ids

	>>> preprocess.read_fastafile('data/neg_small_test.fasta')
	File opened successfully. Now processing sequences
	(['CGCTGCG', 'CGTGTGAAAAAA', 'TGCGTG', 'AGGCGCG', 'TTTAATAAAAAAAA'], ['chr1:500-505', 'chr4:700-710', 'chr1:700-705', 'chr5:800-805', 		'chr6:900-905'])

	
	
	>>> preprocess.read_fastafile('data/pos_small_test.fasta')
	File opened successfully. Now processing sequences
	(['AACCGG', 'AAGGCCAAAAAA', 'TGCGCG', 'AGTGCG', 'AGTTCG'], ['chr1:600-605', 'chr2:700-710', 'chr3:700-705', 'chr4:800-805', 'chr5:900-905'])

	"""
	
	sids = []
	seqs = []

	try:
		f = open(filename, 'r')
		lines = f.readlines()
		f.close()

	except IOError, (errno, strerror):
		print "I/O error(%d): %s" % (errno, strerror)
		sys.exit(0)
	print "File opened successfully. Now processing sequences"
	seq = [] 
	for line in lines:
		if line[0] == '>':
			sids.append(line[1:].rstrip('\n').split()[0])
			if seq != []: seqs.append("".join(seq))
			seq = []
		else:
			if subs:
				seq.append(line.rstrip('\n').upper().replace('N', 'A'))
			else:
				seq.append(line.rstrip('\n').upper())

	if seq != []:
		seqs.append("".join(seq))

	return seqs, sids



def kmerid2kmer(kmerid, kmerlen):
	"""Returns the kmer corresponding to the kmerid defined in the kmer_id_dict

	:author Dongwon Lee (2011)
	

	Arguments:
	kmerid -- integer, id of k-mer
	kmerlen -- integer, length of k-mer

	Return:
	kmer string

	>>> kmerlist=preprocess.generate_kmers(2)
	>>> rev_comp_list=preprocess.generate_rcmap_table(2,kmerlist,True)
	{'AA': 0, 'AC': 1, 'GT': 11, 'AG': 2, 'CC': 5, 'CA': 4, 'CG': 6, 'TT': 15, 'GG': 10, 'GC': 9, 'AT': 3, 'GA': 8, 'TG': 14, 'TA': 12, 'TC': 13, 'CT': 		7}
	>>> preprocess.kmerid2kmer(11,2)
	'GT'
	>>> preprocess.kmerid2kmer(14,2)
	'TG'
	"""

	nts = "ACGT"
	kmernts = []
	kmerid2 = kmerid

	for i in xrange(kmerlen):
		ntid = kmerid2 % 4
		kmernts.append(nts[ntid])
		kmerid2 = int((kmerid2-ntid)/4)

	return ''.join(reversed(kmernts))


def kmer2kmerid(kmer, kmerlen):
	"""returns the kmerid corresponding to the kmer
	:author Dongwon Lee (2011)

	Arguments:
	kmerid -- integer, id of k-mer
	kmerlen -- integer, length of k-mer

	Return:
	id of k-mer

	>>> kmerlist=preprocess.generate_kmers(2)
	>>> rev_comp_map=preprocess.generate_rcmap_table(2, kmerlist, True)
	{'AA': 0, 'AC': 1, 'GT': 11, 'AG': 2, 'CC': 5, 'CA': 4, 'CG': 6, 'TT': 15, 'GG': 10, 'GC': 9, 'AT': 3, 'GA': 8, 'TG': 14, 'TA': 12, 'TC': 13, 'CT': 		7}
	>>> preprocess.kmer2kmerid('AG',2)
	2

	"""

	nt2id = {'A':0, 'C':1, 'G':2, 'T':3}

	return reduce(lambda x, y: (4*x+y), [nt2id[x] for x in kmer])





"""
Class for creating, manipulating and storing sequence data matrices.
Shogun and SKLearn require matrices with different properties and this is intended
to supply that functionality and flexibility
"""

class Matrix:
	"""
	Class for creating, manipulating and storing data matrices from DNA sequence data
	:author Camilla Montonen (2014)
	"""
	def __init__(self,norm,pos_seq, neg_seq, pos_ids, neg_ids, kmerlen):
		"""
		Constructor sets the boolean normalization flag (True or False) and the method ("Shogun or SK")
		:author Camilla Montonen (2014)

		>>> new_matrix=Matrix(True, "Shogun")
		>>> new_matrix.normalization
		True
		>>> new_matrix.method
		'Shogun'

		"""
		self.normalization=norm
		self.positive_sequences=pos_seq
		self.positive_ids=pos_ids
		self.negative_sequences=neg_seq
		self.negative_ids=neg_ids
		self.training_sequences=self.positive_sequences+self.negative_sequences
		self.training_ids=self.positive_ids+self.negative_ids

		#initialise the matrix to an appropriate state
		self.make_matrix(kmerlen)
		self.make_labels()
		

	def make_matrix(self,kmerlen):
		"""
		Returns a matrix (2-D numpy array corresponding to the method specs of Shogun or SK) and a dict of sequence IDs
		:author Camilla Montonen (2014)


		>>> matrix1=Matrix(True,"Shogun")
		>>> matrix1.make_matrix(['AACC','AAAA','TGTT'],['>seq1','>seq2','>seq3'],2)
		Matrix has been successfully computed. This matrix will not be stored.
		>>> matrix1.datamatrix
		array([[ 0.57735027,  1.        ,  0.57735027],
		       [ 0.57735027,  0.        ,  0.57735027],
		       [ 0.        ,  0.        ,  0.        ],
		       [ 0.        ,  0.        ,  0.        ],
		       [ 0.        ,  0.        ,  0.57735027],
		       [ 0.57735027,  0.        ,  0.        ],
		       [ 0.        ,  0.        ,  0.        ],
		       [ 0.        ,  0.        ,  0.        ],
		       [ 0.        ,  0.        ,  0.        ],
		       [ 0.        ,  0.        ,  0.        ],
		       [ 0.        ,  0.        ,  0.        ],
		       [ 0.        ,  0.        ,  0.        ],
		       [ 0.        ,  0.        ,  0.        ],
		       [ 0.        ,  0.        ,  0.        ],
		       [ 0.        ,  0.        ,  0.        ],
		       [ 0.        ,  0.        ,  0.        ]])

		>>> matrix1.sq_ids
		OrderedDict([(0, '>seq1'), (1, '>seq2'), (2, '>seq3')])
		"""
		kmer_list=generate_kmers(kmerlen)
		#generate the reverse mapping list
		rc_map=generate_rcmap_table(kmerlen,kmer_list)
		#initialise the sq_id dict
		sq_ids=OrderedDict()
		#initialise the outer wrapper for the matrix
		matrix=[]
		#initialise each sample row
		matrix_row=0
		for sequence in self.training_sequences:
			x=[0]*(4**kmerlen)
			for j in range(len(sequence)-kmerlen+1):
				x[rc_map[kmer2kmerid(sequence[j:j+kmerlen],kmerlen)]]+=1
			if self.normalization:
				#make x into a numpy.array for the duration of the normalization
				x=numpy.array(x, numpy.double)
				x=x/(numpy.sqrt(numpy.sum(x**2)))
				x=x.tolist()
			#save the row
			matrix.append(x)
			#save the sequence id corresponding to the sample row
			sq_ids.__setitem__(matrix_row,self.training_ids[matrix_row])
			matrix_row+=1
		matrix=numpy.array(matrix)
		print "Matrix has been successfully computed. This matrix will be stored in self.datamatrix."
		self.data=matrix
		self.sq_id_dict=sq_ids

	def make_labels(self,positive_class=1.0,negative_class=-1.0):
		"""
		Returns a list of labels corresponding to the feature vectors in self.datamatrix
		"""
		self.training_labels=[positive_class]*len(self.positive_sequences)+[negative_class]*len(self.negative_sequences)
		

		
	def datamatrix_to_file(self, filename):
		"""
		Writes the numpy array stored in self.datamatrix to an output file with extension .npy

		>>> matrix1=Matrix(True,"SK")
		>>> matrix1.make_matrix(['AAAA','CCCC','GGGG'],['>seq1','>seq2','>seq3'],2)
		Matrix has been successfully computed. This matrix will be stored in self.datamatrix.
		>>> matrix1.datamatrix_to_file('matrix1_sk')
		Saved successfully
		
		This is what happens if make_matrix is not called first
		 NEEDS FIXING	
		"""
		if self.data is None:
			raise NoMatrixError("No matrix to write. Please create the matrix first using make_matrix")
		else:
			numpy.save(filename+'.npy',self.data)
			print "Saved successfully"


def select_subset(size, positive_sequences, negative_sequences, positive_ids, negative_ids):
	"""
	Returns a training_set and training_labels of the desired size


	A note on the division property: division of integers into a float is the default behaviour in Python 3, so we have to import
	the module division from __future__ at the very beginning of the file
	"""
	#set the seed for reproducibility
	random.seed(2)
	#initialise the subset sequences

	#make Deep copies of the original lists to avoid a megabug
	pop_positive_sequences=copy.deepcopy(positive_sequences)
	pop_positive_ids=copy.deepcopy(positive_ids)
	pop_negative_sequences=copy.deepcopy(negative_sequences)
	pop_negative_ids=copy.deepcopy(negative_ids)

	subset_positive_sequences=[]
	subset_negative_sequences=[]
	subset_positive_ids=[]
	subset_negative_ids=[]
	
	#calculate the proportion of the positive and negative example 
	prop_positive=len(pop_positive_sequences)/(len(pop_positive_sequences)+len(pop_negative_sequences))
	prop_negative=1-prop_positive

	#calculate the new number of positive and negative examples
	pos_amount=int(math.floor(size*prop_positive))
	print pos_amount
	neg_amount=int(math.floor(size*prop_negative))
	print neg_amount

	#generate the positive sequences first
	for i in range(pos_amount):
		#generate a random position in the original sequence
		position=random.randint(0,len(pop_positive_sequences)-1)
		subset_positive_sequences.append(pop_positive_sequences.pop(position))
		subset_positive_ids.append(pop_positive_ids.pop(position))

	
	for i in range(neg_amount):
		#generate a random position in the original sequence
		position=random.randint(0,len(pop_negative_sequences)-1)
		subset_negative_sequences.append(pop_negative_sequences.pop(position))
		subset_negative_ids.append(pop_negative_ids.pop(position))

	return subset_positive_sequences, subset_negative_sequences, subset_positive_ids, subset_negative_ids


def write_sequences_to_file(seqs, ids, filename):
	"""
	Writes the sequences in the list to the specified filename. Provides FASTA style headers from the supplied
	sequence ID list. 
	"""
	outputfile=open(filename+".fasta",'w')
	for i in range(len(ids)):
		id_header='>'+ids[i]+'\n'
		outputfile.write(id_header)
		outputfile.write(seqs[i]+'\n')
	outputfile.close()
	print "Finished writing sequences to file"





		
	

